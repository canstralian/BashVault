"""
Vulnerability Scanner Module
Performs basic vulnerability scanning and security checks
"""

import socket
import requests
import concurrent.futures
import time
import re
import ssl
from urllib.parse import urljoin, urlparse
import json

class VulnerabilityScanner:
    def __init__(self, verbose=False, timeout=10):
        """
        Initialize vulnerability scanner
        
        Args:
            verbose (bool): Enable verbose output  
            timeout (int): Connection timeout in seconds
        """
        self.verbose = verbose
        self.timeout = timeout
        
        # Common vulnerability patterns and checks
        self.vulnerability_db = {
            'web_vulnerabilities': {
                'sql_injection': {
                    'payloads': ["'", "1' OR '1'='1", "'; DROP TABLE users; --"],
                    'detection_patterns': ['sql', 'mysql', 'oracle', 'error', 'syntax']
                },
                'xss': {
                    'payloads': ['<script>alert("XSS")</script>', '<img src=x onerror=alert(1)>'],
                    'detection_patterns': ['<script>', 'alert(', 'onerror=']
                },
                'directory_traversal': {
                    'payloads': ['../../../etc/passwd', '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts'],
                    'detection_patterns': ['root:', 'daemon:', 'www-data:', '[system32]']
                }
            },
            'service_vulnerabilities': {
                'ftp_anonymous': {'port': 21, 'check': 'anonymous_ftp'},
                'ssh_weak_auth': {'port': 22, 'check': 'ssh_weak_auth'},
                'telnet_enabled': {'port': 23, 'check': 'telnet_check'},
                'smtp_open_relay': {'port': 25, 'check': 'smtp_relay'},
                'dns_zone_transfer': {'port': 53, 'check': 'dns_zone_transfer'},
                'http_methods': {'port': 80, 'check': 'http_methods'},
                'https_methods': {'port': 443, 'check': 'http_methods'},
                'snmp_public': {'port': 161, 'check': 'snmp_check'}
            }
        }
        
        # Common web directories and files
        self.common_paths = [
            '/admin', '/administrator', '/login', '/wp-admin', '/phpmyadmin',
            '/backup', '/config', '/test', '/dev', '/api', '/uploads',
            '/robots.txt', '/sitemap.xml', '/.git', '/.svn', '/config.php',
            '/phpinfo.php', '/info.php', '/test.php', '/backup.sql'
        ]
    
    def scan(self, target, ports):
        """
        Perform comprehensive vulnerability scan
        
        Args:
            target (str): Target hostname or IP
            ports (str): Port specification
            
        Returns:
            dict: Vulnerability scan results
        """
        results = {
            'target': target,
            'scan_time': time.strftime('%Y-%m-%d %H:%M:%S'),
            'service_vulnerabilities': {},
            'web_vulnerabilities': {},
            'network_vulnerabilities': {},
            'information_disclosure': {},
            'summary': {
                'total_vulnerabilities': 0,
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'informational': 0
            }
        }
        
        try:
            if self.verbose:
                print(f"    [+] Starting vulnerability scan on {target}")
            
            # Parse ports
            port_list = self._parse_ports(ports)
            
            # Service vulnerability scanning
            results['service_vulnerabilities'] = self._scan_service_vulnerabilities(target, port_list)
            
            # Web application vulnerability scanning
            web_ports = [p for p in port_list if p in [80, 443, 8080, 8443, 8000, 8888]]
            if web_ports:
                results['web_vulnerabilities'] = self._scan_web_vulnerabilities(target, web_ports)
            
            # Network-level vulnerability scanning
            results['network_vulnerabilities'] = self._scan_network_vulnerabilities(target, port_list)
            
            # Information disclosure checks
            results['information_disclosure'] = self._check_information_disclosure(target, port_list)
            
            # Calculate summary
            results['summary'] = self._calculate_vulnerability_summary(results)
        
        except Exception as e:
            results['error'] = f"Vulnerability scan error: {str(e)}"
            if self.verbose:
                print(f"    [ERROR] {str(e)}")
        
        return results
    
    def _parse_ports(self, ports):
        """Parse port specification into list of integers"""
        port_list = []
        
        if isinstance(ports, str):
            if '-' in ports:
                start, end = map(int, ports.split('-'))
                port_list = list(range(start, end + 1))
            elif ',' in ports:
                port_list = [int(p.strip()) for p in ports.split(',')]
            else:
                port_list = [int(ports)]
        elif isinstance(ports, list):
            port_list = ports
        
        return port_list
    
    def _scan_service_vulnerabilities(self, target, ports):
        """Scan for service-specific vulnerabilities"""
        service_vulns = {}
        
        def check_service_vuln(port):
            port_vulns = []
            
            # Check if port is open first
            if not self._is_port_open(target, port):
                return port, port_vulns
            
            # Check service-specific vulnerabilities
            for vuln_name, vuln_info in self.vulnerability_db['service_vulnerabilities'].items():
                if vuln_info['port'] == port:
                    check_method = getattr(self, f"_check_{vuln_info['check']}", None)
                    if check_method:
                        try:
                            result = check_method(target, port)
                            if result:
                                port_vulns.append({
                                    'vulnerability': vuln_name,
                                    'description': result.get('description', ''),
                                    'severity': result.get('severity', 'Medium'),
                                    'evidence': result.get('evidence', ''),
                                    'remediation': result.get('remediation', '')
                                })
                        except Exception as e:
                            if self.verbose:
                                print(f"    [ERROR] Error checking {vuln_name}: {str(e)}")
            
            return port, port_vulns
        
        # Use ThreadPoolExecutor for parallel vulnerability checking
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            future_to_port = {executor.submit(check_service_vuln, port): port for port in ports}
            
            for future in concurrent.futures.as_completed(future_to_port):
                port, vulns = future.result()
                if vulns:
                    service_vulns[port] = vulns
                    if self.verbose:
                        print(f"    [+] Found {len(vulns)} vulnerability(ies) on port {port}")
        
        return service_vulns
    
    def _scan_web_vulnerabilities(self, target, web_ports):
        """Scan for web application vulnerabilities"""
        web_vulns = {}
        
        for port in web_ports:
            if not self._is_port_open(target, port):
                continue
            
            protocol = 'https' if port in [443, 8443] else 'http'
            base_url = f"{protocol}://{target}:{port}"
            
            port_vulns = []
            
            try:
                if self.verbose:
                    print(f"    [+] Scanning web vulnerabilities on {base_url}")
                
                # Directory traversal
                port_vulns.extend(self._check_directory_traversal(base_url))
                
                # Common file/directory discovery
                port_vulns.extend(self._check_common_files(base_url))
                
                # HTTP security headers
                port_vulns.extend(self._check_security_headers(base_url))
                
                # HTTP methods
                port_vulns.extend(self._check_http_methods_vuln(base_url))
                
                # Server information disclosure
                port_vulns.extend(self._check_server_disclosure(base_url))
                
                # Basic XSS check (limited)
                port_vulns.extend(self._check_basic_xss(base_url))
                
                if port_vulns:
                    web_vulns[port] = port_vulns
            
            except Exception as e:
                if self.verbose:
                    print(f"    [ERROR] Web vulnerability scan error on port {port}: {str(e)}")
        
        return web_vulns
    
    def _scan_network_vulnerabilities(self, target, ports):
        """Scan for network-level vulnerabilities"""
        network_vulns = []
        
        try:
            # Check for common network vulnerabilities
            
            # Open port analysis
            open_ports = [p for p in ports if self._is_port_open(target, p)]
            if len(open_ports) > 20:
                network_vulns.append({
                    'vulnerability': 'Excessive open ports',
                    'description': f'Found {len(open_ports)} open ports, which may increase attack surface',
                    'severity': 'Low',
                    'evidence': f'Open ports: {open_ports[:20]}...',
                    'remediation': 'Close unnecessary ports and services'
                })
            
            # Check for high-numbered ports (potential backdoors)
            high_ports = [p for p in open_ports if p > 10000]
            if high_ports:
                network_vulns.append({
                    'vulnerability': 'High-numbered ports open',
                    'description': 'High-numbered ports may indicate backdoors or unauthorized services',
                    'severity': 'Medium',
                    'evidence': f'High ports: {high_ports}',
                    'remediation': 'Investigate and close unauthorized high-numbered ports'
                })
            
            # Check for common vulnerable services
            vulnerable_services = {
                23: {'name': 'Telnet', 'severity': 'High', 'reason': 'Unencrypted communication'},
                513: {'name': 'rlogin', 'severity': 'High', 'reason': 'Insecure remote login'},
                514: {'name': 'rsh', 'severity': 'High', 'reason': 'Insecure remote shell'},
                1433: {'name': 'MSSQL', 'severity': 'Medium', 'reason': 'Database exposure'},
                3306: {'name': 'MySQL', 'severity': 'Medium', 'reason': 'Database exposure'},
                5432: {'name': 'PostgreSQL', 'severity': 'Medium', 'reason': 'Database exposure'},
                6379: {'name': 'Redis', 'severity': 'Medium', 'reason': 'Database exposure'}
            }
            
            for port in open_ports:
                if port in vulnerable_services:
                    service = vulnerable_services[port]
                    network_vulns.append({
                        'vulnerability': f'{service["name"]} service exposed',
                        'description': f'{service["name"]} service on port {port}: {service["reason"]}',
                        'severity': service['severity'],
                        'evidence': f'Port {port} is open',
                        'remediation': f'Secure or firewall {service["name"]} service'
                    })
        
        except Exception as e:
            if self.verbose:
                print(f"    [ERROR] Network vulnerability scan error: {str(e)}")
        
        return network_vulns
    
    def _check_information_disclosure(self, target, ports):
        """Check for information disclosure vulnerabilities"""
        info_disclosure = {}
        
        try:
            # Banner grabbing
            banners = {}
            for port in ports[:10]:  # Limit to first 10 ports for performance
                if self._is_port_open(target, port):
                    banner = self._grab_banner(target, port)
                    if banner:
                        banners[port] = banner
            
            info_disclosure['banners'] = banners
            
            # HTTP server information (if web ports are available)
            web_ports = [p for p in ports if p in [80, 443, 8080, 8443]]
            if web_ports:
                info_disclosure['http_headers'] = self._get_http_server_info(target, web_ports[0])
        
        except Exception as e:
            info_disclosure['error'] = str(e)
        
        return info_disclosure
    
    def _is_port_open(self, target, port):
        """Check if a port is open"""
        try:
            with socket.create_connection((target, port), timeout=3):
                return True
        except:
            return False
    
    def _grab_banner(self, target, port):
        """Grab service banner from port"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((target, port))
            
            # Send a probe for common services
            if port == 21:  # FTP
                pass  # FTP sends banner immediately
            elif port == 22:  # SSH
                pass  # SSH sends banner immediately
            elif port == 25:  # SMTP
                pass  # SMTP sends banner immediately
            elif port in [80, 8080]:  # HTTP
                sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
            elif port in [443, 8443]:  # HTTPS
                # Skip HTTPS banner grabbing for simplicity
                sock.close()
                return None
            elif port == 110:  # POP3
                pass  # POP3 sends banner immediately
            else:
                sock.send(b"\r\n")
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
            sock.close()
            return banner
        except:
            return None
    
    def _get_http_server_info(self, target, port):
        """Get HTTP server information"""
        server_info = {}
        
        try:
            protocol = 'https' if port in [443, 8443] else 'http'
            url = f"{protocol}://{target}:{port}/"
            
            response = requests.head(url, timeout=self.timeout, verify=False, allow_redirects=False)
            
            headers_of_interest = ['server', 'x-powered-by', 'x-aspnet-version', 
                                 'x-generator', 'x-drupal-cache', 'x-varnish']
            
            for header in headers_of_interest:
                if header in response.headers:
                    server_info[header] = response.headers[header]
        
        except:
            pass
        
        return server_info
    
    # Service-specific vulnerability checks
    def _check_anonymous_ftp(self, target, port):
        """Check for anonymous FTP access"""
        try:
            import ftplib
            ftp = ftplib.FTP()
            ftp.connect(target, port, timeout=self.timeout)
            
            try:
                ftp.login('anonymous', 'anonymous@')
                ftp.quit()
                return {
                    'description': 'Anonymous FTP access is enabled',
                    'severity': 'Medium',
                    'evidence': 'Successfully logged in with anonymous credentials',
                    'remediation': 'Disable anonymous FTP access or restrict permissions'
                }
            except:
                ftp.quit()
                return None
        except:
            return None
    
    def _check_ssh_weak_auth(self, target, port):
        """Check for SSH weak authentication"""
        try:
            import paramiko
            
            # Test common weak credentials
            weak_creds = [
                ('root', 'root'), ('admin', 'admin'), ('admin', 'password'),
                ('root', ''), ('admin', ''), ('guest', 'guest')
            ]
            
            for username, password in weak_creds:
                try:
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(target, port=port, username=username, password=password, timeout=5)
                    ssh.close()
                    
                    return {
                        'description': f'SSH accepts weak credentials: {username}/{password}',
                        'severity': 'Critical',
                        'evidence': f'Successfully authenticated with {username}:{password}',
                        'remediation': 'Use strong passwords and disable password authentication'
                    }
                except:
                    continue
        except ImportError:
            if self.verbose:
                print("    [WARNING] paramiko not available for SSH testing")
        except:
            pass
        
        return None
    
    def _check_telnet_check(self, target, port):
        """Check if Telnet is enabled"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((target, port))
            sock.close()
            
            if result == 0:
                return {
                    'description': 'Telnet service is running (insecure)',
                    'severity': 'High',
                    'evidence': f'Telnet service detected on port {port}',
                    'remediation': 'Disable Telnet and use SSH instead'
                }
        except:
            pass
        
        return None
    
    def _check_smtp_relay(self, target, port):
        """Check for SMTP open relay"""
        try:
            import smtplib
            
            smtp = smtplib.SMTP(timeout=self.timeout)
            smtp.connect(target, port)
            
            # Try to send a test email to detect open relay
            try:
                smtp.mail('test@example.com')
                smtp.rcpt('test@external.com')
                smtp.quit()
                
                return {
                    'description': 'SMTP server may be an open relay',
                    'severity': 'High',
                    'evidence': 'SMTP server accepted external relay request',
                    'remediation': 'Configure SMTP server to reject unauthorized relaying'
                }
            except:
                smtp.quit()
        except:
            pass
        
        return None
    
    def _check_dns_zone_transfer(self, target, port):
        """Check for DNS zone transfer vulnerability"""
        try:
            import dns.zone
            import dns.query
            
            # This is a basic check - would need domain name for actual zone transfer
            return None  # Placeholder
        except ImportError:
            if self.verbose:
                print("    [WARNING] dnspython not available for DNS testing")
        except:
            pass
        
        return None
    
    def _check_http_methods(self, target, port):
        """Check for dangerous HTTP methods"""
        try:
            protocol = 'https' if port in [443, 8443] else 'http'
            url = f"{protocol}://{target}:{port}/"
            
            dangerous_methods = ['PUT', 'DELETE', 'TRACE', 'CONNECT']
            enabled_methods = []
            
            for method in dangerous_methods:
                try:
                    response = requests.request(method, url, timeout=5, verify=False)
                    if response.status_code not in [405, 501]:  # Method Not Allowed, Not Implemented
                        enabled_methods.append(method)
                except:
                    continue
            
            if enabled_methods:
                return {
                    'description': f'Dangerous HTTP methods enabled: {", ".join(enabled_methods)}',
                    'severity': 'Medium',
                    'evidence': f'Methods {enabled_methods} are allowed',
                    'remediation': 'Disable unnecessary HTTP methods'
                }
        except:
            pass
        
        return None
    
    def _check_snmp_check(self, target, port):
        """Check for SNMP with default community strings"""
        try:
            # Basic SNMP check - would require pysnmp for full implementation
            return {
                'description': 'SNMP service detected',
                'severity': 'Low',
                'evidence': f'SNMP service on port {port}',
                'remediation': 'Secure SNMP with SNMPv3 or firewall access'
            }
        except:
            pass
        
        return None
    
    # Web vulnerability checks
    def _check_directory_traversal(self, base_url):
        """Check for directory traversal vulnerabilities"""
        vulns = []
        
        payloads = ['../../../etc/passwd', '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts']
        
        for payload in payloads:
            try:
                url = f"{base_url}/{payload}"
                response = requests.get(url, timeout=5, verify=False)
                
                content = response.text.lower()
                if any(pattern in content for pattern in ['root:', 'daemon:', 'www-data:', '[fonts]']):
                    vulns.append({
                        'vulnerability': 'Directory Traversal',
                        'description': 'Server is vulnerable to directory traversal attacks',
                        'severity': 'High',
                        'evidence': f'Payload "{payload}" revealed system files',
                        'remediation': 'Implement proper input validation and access controls'
                    })
                    break
            except:
                continue
        
        return vulns
    
    def _check_common_files(self, base_url):
        """Check for common sensitive files and directories"""
        vulns = []
        found_files = []
        
        def check_path(path):
            try:
                url = urljoin(base_url, path)
                response = requests.get(url, timeout=5, verify=False, allow_redirects=False)
                if response.status_code == 200:
                    return path
            except:
                pass
            return None
        
        # Use ThreadPoolExecutor for parallel file checking
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            future_to_path = {executor.submit(check_path, path): path for path in self.common_paths}
            
            for future in concurrent.futures.as_completed(future_to_path):
                result = future.result()
                if result:
                    found_files.append(result)
        
        if found_files:
            vulns.append({
                'vulnerability': 'Sensitive files/directories exposed',
                'description': 'Common sensitive files or directories are accessible',
                'severity': 'Medium',
                'evidence': f'Found: {", ".join(found_files[:10])}',
                'remediation': 'Remove or protect sensitive files and directories'
            })
        
        return vulns
    
    def _check_security_headers(self, base_url):
        """Check for missing security headers"""
        vulns = []
        
        try:
            response = requests.get(base_url, timeout=self.timeout, verify=False)
            headers = response.headers
            
            missing_headers = []
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection',
                'X-Content-Type-Options': 'MIME type sniffing protection',
                'X-XSS-Protection': 'XSS protection',
                'Strict-Transport-Security': 'HTTPS enforcement',
                'Content-Security-Policy': 'Content injection protection'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    missing_headers.append(f"{header} ({description})")
            
            if missing_headers:
                vulns.append({
                    'vulnerability': 'Missing security headers',
                    'description': 'Important security headers are missing',
                    'severity': 'Low',
                    'evidence': f'Missing headers: {", ".join(missing_headers)}',
                    'remediation': 'Implement security headers to protect against common attacks'
                })
        except:
            pass
        
        return vulns
    
    def _check_http_methods_vuln(self, base_url):
        """Check for dangerous HTTP methods (web-specific)"""
        vulns = []
        
        dangerous_methods = ['PUT', 'DELETE', 'TRACE', 'CONNECT', 'PATCH']
        enabled_methods = []
        
        for method in dangerous_methods:
            try:
                response = requests.request(method, base_url, timeout=5, verify=False)
                if response.status_code not in [405, 501]:
                    enabled_methods.append(method)
            except:
                continue
        
        if enabled_methods:
            vulns.append({
                'vulnerability': 'Dangerous HTTP methods enabled',
                'description': 'Server accepts potentially dangerous HTTP methods',
                'severity': 'Medium',
                'evidence': f'Enabled methods: {", ".join(enabled_methods)}',
                'remediation': 'Disable unnecessary HTTP methods'
            })
        
        return vulns
    
    def _check_server_disclosure(self, base_url):
        """Check for server information disclosure"""
        vulns = []
        
        try:
            response = requests.get(base_url, timeout=self.timeout, verify=False)
            
            # Check for verbose server headers
            server_header = response.headers.get('Server', '')
            if server_header and any(keyword in server_header.lower() for keyword in 
                                   ['apache/', 'nginx/', 'iis/', 'version']):
                vulns.append({
                    'vulnerability': 'Server version disclosure',
                    'description': 'Server header reveals version information',
                    'severity': 'Low',
                    'evidence': f'Server header: {server_header}',
                    'remediation': 'Configure server to hide version information'
                })
            
            # Check for technology disclosure in headers
            tech_headers = ['X-Powered-By', 'X-AspNet-Version', 'X-Generator']
            for header in tech_headers:
                if header in response.headers:
                    vulns.append({
                        'vulnerability': 'Technology disclosure',
                        'description': f'Technology information disclosed in {header} header',
                        'severity': 'Low',
                        'evidence': f'{header}: {response.headers[header]}',
                        'remediation': f'Remove or modify {header} header'
                    })
        except:
            pass
        
        return vulns
    
    def _check_basic_xss(self, base_url):
        """Basic XSS vulnerability check"""
        vulns = []
        
        # This is a very basic XSS check - real XSS testing requires more sophisticated payloads
        try:
            xss_payload = '<script>alert("XSS")</script>'
            test_url = f"{base_url}?q={xss_payload}"
            
            response = requests.get(test_url, timeout=5, verify=False)
            if xss_payload in response.text:
                vulns.append({
                    'vulnerability': 'Potential XSS vulnerability',
                    'description': 'Input may not be properly sanitized (basic test)',
                    'severity': 'Medium',
                    'evidence': 'XSS payload reflected in response',
                    'remediation': 'Implement proper input validation and output encoding'
                })
        except:
            pass
        
        return vulns
    
    def _calculate_vulnerability_summary(self, results):
        """Calculate vulnerability summary statistics"""
        summary = {
            'total_vulnerabilities': 0,
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'informational': 0
        }
        
        # Count service vulnerabilities
        for port, vulns in results.get('service_vulnerabilities', {}).items():
            for vuln in vulns:
                summary['total_vulnerabilities'] += 1
                severity = vuln.get('severity', 'Medium').lower()
                if severity in summary:
                    summary[severity] += 1
        
        # Count web vulnerabilities
        for port, vulns in results.get('web_vulnerabilities', {}).items():
            for vuln in vulns:
                summary['total_vulnerabilities'] += 1
                severity = vuln.get('severity', 'Medium').lower()
                if severity in summary:
                    summary[severity] += 1
        
        # Count network vulnerabilities
        for vuln in results.get('network_vulnerabilities', []):
            summary['total_vulnerabilities'] += 1
            severity = vuln.get('severity', 'Medium').lower()
            if severity in summary:
                summary[severity] += 1
        
        return summary
